<VevaciousModelFile>

<ModelFileDetails
 ModelName="MssmJustNormalHiggsStopStauSnu"
 VevaciousMajorVersion="2" VevaciousMinorVersion="0" />

<!-- All variables which are NOT explicitly given in AllowedNonZeroVariables
     are assumed to be zero. This allows for a model to be given in terms of
     all possible scalar fields, while slight edits to AllowedNonZeroVariables
     can then specify which fields are assumed to be zero (by omission from
     AllowedNonZeroVariables). -->
<AllowedNonZeroVariables>

  <!-- The fields should be given as a newline-separated list of character
       strings. Field names should be strings of alphanumeric characters but
       may not begin with a numeric digit, and may also include a
       comma-separated list of integers in square brackets after the
       alphanumeric string (spaces allowed within the square brackets, but
       nowhere else). The names are also case-sensitive.
       Examples:
       phi
       phi1 (is distinct from just phi)
       h
       H (is distinct from h)
       stopleftvev
       vSeL[-1,3]
       MatrixOfFields[4, 2]
       f1g3
       and so on.
       
       The values of the fields at the desired symmetry-breaking (DSB) minimum
       (i.e. the minimum that should be the physical vacuum for the parameter
       point if it's physically acceptable) are given later, in DsbMinimum,
       after DerivedParameters so that values from the SLHA input can be
       referenced. -->
  <FieldVariables>
    Hd
    Hu
    <!--
    L[-1,3]
    E[3]
    L[+1,2]
    -->
    Q[+1,3]
    U[3]
  </FieldVariables>
  
  <!-- Every block that will be read in from an SLHA file should be enumerated
       here in a newline-separated list. Block names are NOT case-sensitive
       (following the SLHA conventions). Any blocks not explicitly mentioned
       here will be treated as zero in the rest of the model file!
       N.B.: Only a subset of possible SLHA-style blocks are permitted: those
       where each line is of the form of a set of integer indices followed by
       a single floating-point number. The number of indices is not limited.
       For a block named BLAH, the elements are referred to in this model file
       as BLAH[ 1 ] or BLAH[ 2, 3 ] or BLAH[4,5,6] and so on for blocks with
       1, 2 or 3 indices and so on. Also, blocks which are just a single line
       with a single floating-point number are permitted, but must be referred
       to with empty square brackets: BLAH[] (e.g. the ALPHA block of the
       original SUSY Les Houches Accords).
       Aliases for the blocks may also be given here, by NAME = alias. For
       example, GAUGE = g would both denote that the GAUGE block is to be read
       in from the SLHA file, and also that g[1] in the rest of this model file
       is equivalent to GAUGE[1] and so on. -->
  <SlhaBlocks>
    GAUGE
    HMIX
    TREEHMIX
    LOOPHMIX
    EXTPAR
    MSOFT
    TREEMSOFT
    LOOPMSOFT
    MSQ2
    MSU2
    MSD2
    MSL2
    MSE2
    YU
    TU
    YD
    TD
    YE
    TE
  </SlhaBlocks>

  <!-- Every other non-zero parameter should appear here, each on a separate
       line, in the form
       (variable name)=(type of variable)[(list of relevant arguments)]
       and if a parameter references another parameter, it MUST come further
       down the list than the referenced parameter. (All elements of SLHA
       blocks from SlhaBlocks may be referenced here but only through first
       creating parameters of the SLHAELEMENT type.) Constant numbers may be
       used in places of aliases.
       Allowed types:
       SLHAELEMENT: takes SLHA block name or alias, then set of indices,
                    e.g. SLHAELEMENT[YU, 2, 3]
                    
       Binary operations: all these take 2 aliases as arguments,
                          e.g. DIVIDE[ blah, bloop ] or PLUS[ 2.0, foo ]
       PLUS: adds the arguments
       MINUS: subtracts the 2nd argument from the 1st
       TIMES: multiplies the arguments
       DIVIDE: divides the 1st argument by the 2nd
       POW: raises the 1st argument to the power of the 2nd
       IFNONZERO: the 1st argument unless it is 0.0, in which case the 2nd
       
       Unary operations: all these take 1 alias as the argument,
                         e.g. ATAN[ bar ] or SQRT[ 6 ]
       SQRT: square root
       EXP: e to the power of the argument
       LOG: logarithm in base e
       TAN: tangent
       SIN: sine
       COS: cosine
       TAN: tangent
       ASIN: arcsine (inverse sine)
       ACOS: arccosine (inverse cosine)
       ATAN: arctangent (inverse tangent)
       SINH: hyperbolic sine
       COSH: hyperbolic cosine
       TANH: hyperbolic tangent -->
  <DerivedParameters>
  <!-- Almost all of this is to cover the renormalization scheme used by
       SARAH4. -->
    tanBetaSlha=SLHAELEMENT[HMIX, 2]
    tanBetaSarah=SLHAELEMENT[EXTPAR, 25]
    tanBeta=IFNONZERO[tanBetaSarah, tanBetaSlha]
    betaSlha=ATAN[ tanBeta ]
    sinBetaSlha=SIN[ betaSlha ]
    cosBetaSlha=COS[ betaSlha ]
    vSlha=SLHAELEMENT[HMIX, 3]
    vdSlha=TIMES[ cosBetaSlha, vSlha ]
    vuSlha=TIMES[ sinBetaSlha, vSlha ]
    vdSarah=SLHAELEMENT[HMIX, 102]
    vuSarah=SLHAELEMENT[HMIX, 103]
    vd=IFNONZERO[vdSarah, vdSlha]
    vu=IFNONZERO[vuSarah, vuSlha]
    mu=SLHAELEMENT[HMIX, 1]
    muSarahTree=SLHAELEMENT[TREEHMIX, 1]
    muTree=IFNONZERO[muSarahTree, mu]
    muSarahLoop=SLHAELEMENT[LOOPHMIX, 1]
    muLoop=IFNONZERO[muSarahLoop, mu]
    Bmu=SLHAELEMENT[HMIX, 101]
    BmuSarahTree=SLHAELEMENT[TREEHMIX, 101]
    BmuTree=IFNONZERO[BmuSarahTree, Bmu]
    BmuSarahLoop=SLHAELEMENT[LOOPHMIX, 101]
    BmuLoop=IFNONZERO[BmuSarahLoop, Bmu]
    mHdSq=SLHAELEMENT[MSOFT, 21]
    mHdSqSarahTree=SLHAELEMENT[TREEMSOFT, 21]
    mHdSqTree=IFNONZERO[mHdSqSarahTree, mHdSq]
    mHdSqSarahLoop=SLHAELEMENT[LOOPMSOFT, 21]
    mHdSqLoop=IFNONZERO[mHdSqSarahLoop, mHdSq]
    mHuSq=SLHAELEMENT[MSOFT, 22]
    mHuSqSarahTree=SLHAELEMENT[TREEMSOFT, 22]
    mHuSqTree=IFNONZERO[mHuSqSarahTree, mHuSq]
    mHuSqSarahLoop=SLHAELEMENT[LOOPMSOFT, 22]
    mHuSqLoop=IFNONZERO[mHuSqSarahLoop, mHuSq]
  </DerivedParameters>
  
  <!-- Non-zero values for fields from FieldVariables should be specified here
       to give the field configuration of the DSB vacuum. Fields not given
       values here will be assumed to be 0 at the DSB minimum. They should be
       given in the form name = value. The values can be given as a sum of
       polynomial terms in the parameters given by DerivedParameters above, and
       also by SLHA block elements with indices in a comma-separated list in
       square brackets after the block name. In effect, they can be given like
       polynomials in the format of TreeLevelPotential below (including raising
       to a power with '^').
       Examples:
       phi = 246.0
       a = HMIX[ 3 ]
       singlet_field=2.0*NMSSMRUN[1]*NMSSMRUN[3] + 1.0 - HMIX[4]
       x = 0.5 * muOverRootLambda (assuming muOverRootLambda was defined in
                                   DerivedParameters above)
       
       Since the values can (and probably will, in general) reference
       scale-dependent parameters, the attribute EvaluationScale can be given
       in GeV with an explicit floating-point number. For example,
       <DsbMinimum EvaluationScale="1.000E+003" >
       as the opening tag will tell VevaciousPlusPlus to evaluate the
       parameters at a scale of 1 TeV. If a scale is not explicitly given,
       the value given by MinimumRenormalizationScale above is used. This only
       affects RgeImprovedOneLoopPotential instances, as
       FixedScaleOneLoopPotential instances consider all parameters to be
       constant over all scales, so leaving EvaluationScale out will still give
       the same values as putting it in (with any value). -->
  <DsbMinimum>
    Hd = vd
    Hu = vu
  </DsbMinimum>

</AllowedNonZeroVariables>

<!-- Polynomials (which make up the tree-level potential and also the elements
     of the mass-squared matrices) are always expanded out, have no brackets,
     and are interpreted with the standard operator precedence. Raising x to
     the nth power (where n is a natural number) can be written using a caret:
     x^n, for example. This does not work for constant numbers! Division is not
     possible, unfortunately; none of '/', 'Ö', nor "^-" are permitted: please
     expand out e.g. 4.0/8.0 as 0.5 or use DerivedParameters for such things as
     a ratio of parameters from an SLHA file. -->
<!-- The TreeLevelPotential element should be a polynomial as described above.
     It is used as the tree-level part of the potential energy density
     function. -->
<TreeLevelPotential>
 0.03125*Hd^4*GAUGE[1.]^2 
 -0.125*Hd^2*E[3]^2*GAUGE[1.]^2 
 + 0.125*E[3]^4*GAUGE[1.]^2 
 + 0.0625*Hd^2*L[-1,3]^2*GAUGE[1.]^2 
 -0.125*E[3]^2*L[-1,3]^2*GAUGE[1.]^2 
 + 0.03125*L[-1,3]^4*GAUGE[1.]^2 
 + 0.0625*Hd^2*L[+1,2]^2*GAUGE[1.]^2 
 -0.125*E[3]^2*L[+1,2]^2*GAUGE[1.]^2 
 + 0.0625*L[-1,3]^2*L[+1,2]^2*GAUGE[1.]^2 
 + 0.03125*L[+1,2]^4*GAUGE[1.]^2 
 -0.020833333333333332*Hd^2*Q[+1,3]^2*GAUGE[1.]^2 
 + 0.041666666666666664*E[3]^2*Q[+1,3]^2*GAUGE[1.]^2 
 -0.020833333333333332*L[-1,3]^2*Q[+1,3]^2*GAUGE[1.]^2 
 -0.020833333333333332*L[+1,2]^2*Q[+1,3]^2*GAUGE[1.]^2 
 + 0.003472222222222222*Q[+1,3]^4*GAUGE[1.]^2 
 + 0.08333333333333333*Hd^2*U[3]^2*GAUGE[1.]^2 
 -0.16666666666666666*E[3]^2*U[3]^2*GAUGE[1.]^2 
 + 0.08333333333333333*L[-1,3]^2*U[3]^2*GAUGE[1.]^2 
 + 0.08333333333333333*L[+1,2]^2*U[3]^2*GAUGE[1.]^2 
 -0.027777777777777776*Q[+1,3]^2*U[3]^2*GAUGE[1.]^2 
 + 0.05555555555555555*U[3]^4*GAUGE[1.]^2 
 -0.0625*Hd^2*Hu^2*GAUGE[1.]^2 
 + 0.125*E[3]^2*Hu^2*GAUGE[1.]^2 
 -0.0625*L[-1,3]^2*Hu^2*GAUGE[1.]^2 
 -0.0625*L[+1,2]^2*Hu^2*GAUGE[1.]^2 
 + 0.020833333333333332*Q[+1,3]^2*Hu^2*GAUGE[1.]^2 
 -0.08333333333333333*U[3]^2*Hu^2*GAUGE[1.]^2 
 + 0.03125*Hu^4*GAUGE[1.]^2 
 + 0.03125*Hd^4*GAUGE[2.]^2 
 -0.0625*Hd^2*L[-1,3]^2*GAUGE[2.]^2 
 + 0.03125*L[-1,3]^4*GAUGE[2.]^2 
 + 0.0625*Hd^2*L[+1,2]^2*GAUGE[2.]^2 
 -0.0625*L[-1,3]^2*L[+1,2]^2*GAUGE[2.]^2 
 + 0.03125*L[+1,2]^4*GAUGE[2.]^2 
 + 0.0625*Hd^2*Q[+1,3]^2*GAUGE[2.]^2 
 -0.0625*L[-1,3]^2*Q[+1,3]^2*GAUGE[2.]^2 
 + 0.0625*L[+1,2]^2*Q[+1,3]^2*GAUGE[2.]^2 
 + 0.03125*Q[+1,3]^4*GAUGE[2.]^2 
 -0.0625*Hd^2*Hu^2*GAUGE[2.]^2 
 + 0.0625*L[-1,3]^2*Hu^2*GAUGE[2.]^2 
 -0.0625*L[+1,2]^2*Hu^2*GAUGE[2.]^2 
 -0.0625*Q[+1,3]^2*Hu^2*GAUGE[2.]^2 
 + 0.03125*Hu^4*GAUGE[2.]^2 
 + 0.041666666666666664*Q[+1,3]^4*GAUGE[3.]^2 
 -0.08333333333333333*Q[+1,3]^2*U[3]^2*GAUGE[3.]^2 
 + 0.041666666666666664*U[3]^4*GAUGE[3.]^2 
 + 0.5*Hd^2*muTree^2 
 + 0.5*Hu^2*muTree^2 
 -1.*Hd*Hu*BmuTree
 + 0.5*E[3]^2*MSE2[3., 3.] 
 + 0.5*L[+1,2]^2*MSL2[2., 2.] 
 + 0.5*L[-1,3]^2*MSL2[3., 3.] 
 + 0.5*Hd^2*mHdSqTree 
 + 0.5*Hu^2*mHuSqTree 
 + 0.5*Q[+1,3]^2*MSQ2[3., 3.] 
 + 0.5*U[3]^2*MSU2[3., 3.] 
 + 0.7071067811865475*Hd*E[3]*L[-1,3]*TE[3., 3.] 
 + 0.7071067811865475*Q[+1,3]*U[3]*Hu*TU[3., 3.] 
 + 0.25*Hd^2*L[-1,3]^2*YE[1., 3.]^2 
 + 0.25*Hd^2*L[-1,3]^2*YE[2., 3.]^2 
 + 0.25*Hd^2*E[3]^2*YE[3., 1.]^2 
 + 0.25*Hd^2*E[3]^2*YE[3., 2.]^2 
 + 0.25*E[3]^2*L[+1,2]^2*YE[3., 2.]^2 
 -0.7071067811865475*E[3]*L[-1,3]*Hu*muTree*YE[3., 3.] 
 + 0.25*Hd^2*E[3]^2*YE[3., 3.]^2 
 + 0.25*Hd^2*L[-1,3]^2*YE[3., 3.]^2 
 + 0.25*E[3]^2*L[-1,3]^2*YE[3., 3.]^2 
 + 0.25*Q[+1,3]^2*Hu^2*YU[1., 3.]^2 
 + 0.25*Q[+1,3]^2*Hu^2*YU[2., 3.]^2 
 + 0.25*U[3]^2*Hu^2*YU[3., 1.]^2 
 + 0.25*U[3]^2*Hu^2*YU[3., 2.]^2 
 -0.7071067811865475*Hd*Q[+1,3]*U[3]*muTree*YU[3., 3.] 
 + 0.25*Q[+1,3]^2*U[3]^2*YU[3., 3.]^2 
 + 0.25*Q[+1,3]^2*Hu^2*YU[3., 3.]^2 
 + 0.25*U[3]^2*Hu^2*YU[3., 3.]^2 
</TreeLevelPotential>

<!-- The loop corrections come in 2 forms: an additional polynomial in the same
     form as the tree-level potential above (which allows Lagrangian parameters
     to be given as expansions in h-bar), and sets of mass or mass-squared
     matrices.
     
     There is so far only 1 attribute that needs to be given:
     RenormalizationScheme, which can be "MSBAR" or "DRBAR", but the
     renormalization scheme does not have to be strictly MS-bar or DR-bar.
     The regularization is assumed to be dimensional, taking care of the
     divergences, while a loop expansion of the finite parts of the Lagrangian
     parameters can be accommodated with ExtraPolynomialPart, which is added
     as a 1-loop correction to TreeLevelPotential. All that (currently) is
     decided by RenormalizationScheme is whether vector degrees of freedom with
     mass m contribute m^4 (ln[m^2/Q^2] - 5/6) by giving "MSBAR" or instead
     m^4 (ln[m^2/Q^2] - 3/2) by giving "DRBAR" (taking into account the
     "epsilon scalars" of softly-broken supersymmetric models in the "modified
     DR-bar" scheme of Stephen P. Martin, Phys.Rev. D65 (2002) 116003
     http://arxiv.org/abs/hep-ph/0111209). -->
<LoopCorrections RenormalizationScheme="DRBAR" GaugeFixing="LANDAU" >
<!-- No loop corrections in this model file, so that tests can run quickly. -->
</LoopCorrections>

</VevaciousModelFile>