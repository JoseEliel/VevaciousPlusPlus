<VevaciousModelFile>

<ModelFileDetails
 ModelName="PhiFourthTest"
 VevaciousMajorVersion="2" VevaciousMinorVersion="0" />

<!-- All variables which are NOT explicitly given in AllowedNonZeroVariables
     are assumed to be zero. This allows for a model to be given in terms of
     all possible scalar fields, while slight edits to AllowedNonZeroVariables
     can then specify which fields are assumed to be zero (by omission from
     AllowedNonZeroVariables). -->
<AllowedNonZeroVariables>

  <!-- The fields should be given as a newline-separated list of character
       strings. Field names should be strings of alphanumeric characters but
       may not begin with a numeric digit, and may also include a
       comma-separated list of integers in square brackets after the
       alphanumeric string (spaces allowed within the square brackets, but
       nowhere else). The names are also case-sensitive.
       Examples:
       phi
       phi1 (is distinct from just phi)
       h
       H (is distinct from h)
       stopleftvev
       vSel[3]
       MatrixOfFields[4, 2]
       f1g3
       and so on.
       
       The values of the fields at the desired symmetry-breaking (DSB) minimum
       (i.e. the minimum that should be the physical vacuum for the parameter
       point if it's physically acceptable) are given later, in DsbMinimum,
       after DerivedParameters so that values from the SLHA input can be
       referenced.

       Each field name can be followed on the same line by the keyword
       "PositiveByConvention" or by the keyword "NegativeByConvention". Please
       be aware that it is a guide for the code, NOT a property of the model!
       If a field is followed by PositiveByConvention, any starting points for
       gradient-based minimization of the full potential which have negative
       values of this field are discarded rather than used as starting points.
       Similarly a field with the NegativeByConvention must be  <= 0 for a
       starting point to be used. These keywords should only be used if the
       user is ABSOLUTELY SURE that the symmetries of the Lagrangian allow the
       field to always be taken as possible through unphysical field phase
       redefinitions. Hence it is only possible for complex scalar fields, such
       as the neutral components of Hd and Hu in two-Higgs-doublet models:
       if {phi_d = +|v_d|, phi_u = +|v_u|} is a valid minimum,
       {phi_d = -|v_d|, phi_u = -|v_u|} is also valid, and corresponds to the
       same physical vacuum through a rotation of the phases of phi_d and phi_u
       which is also a Goldstone boson direction. In this case, only the
       relative phase of phi_d to phi_u is physical, so e.g. phi_u may be
       taken as positive, so VevaciousPlusPlus won't bother looking at
       {phi_d = -|v_d|, phi_u = -|v_u|}. However, forcing both to be taken
       positive for example will mean that VevaciousPlusPlus would not bother
       looking at {phi_d = +|v_d|, phi_u = -|v_u|} which, for a general
       two-Higgs-doublet model, could correspond to another minimum of the
       potential, which is not physically equivalent to
       {phi_d = +|v_d|, phi_u = +|v_u|}. -->
  <FieldVariables>
    phi
    sigma
  </FieldVariables>
  
  <!-- Every block that will be read in from an SLHA file should be enumerated
       here in a newline-separated list. Block names are NOT case-sensitive
       (following the SLHA conventions). Any blocks not explicitly mentioned
       here will be treated as zero in the rest of the model file!
       N.B.: Only a subset of possible SLHA-style blocks are permitted: those
       where each line is of the form of a set of integer indices followed by
       a single floating-point number. The number of indices is not limited.
       For a block named BLAH, the elements are referred to in this model file
       as BLAH[ 1 ] or BLAH[ 2, 3 ] or BLAH[4,5,6] and so on for blocks with
       1, 2 or 3 indices and so on. Also, blocks which are just a single line
       with a single floating-point number are permitted, but must be referred
       to with empty square brackets: BLAH[] (e.g. the ALPHA block of the
       original SUSY Les Houches Accords).
       Aliases for the blocks may also be given here, by NAME = alias. For
       example, GAUGE = g would both denote that the GAUGE block is to be read
       in from the SLHA file, and also that g[1] in the rest of this model file
       is equivalent to GAUGE[1] and so on. -->
  <SlhaBlocks>
    GAUGE = g
    YU=y
    IMYU
    HMIX
    PHIFOURTH
    LOOPPHIFOURTH
    PHIFOURTHVEVS
  </SlhaBlocks>

  <!-- Every other non-zero parameter should appear here, each on a separate
       line, in the form
       (variable name)=(type of variable)[(list of relevant arguments)]
       and if a parameter references another parameter, it MUST come further
       down the list than the referenced parameter. (All elements of SLHA
       blocks from SlhaBlocks may be referenced here but only through first
       creating parameters of the SLHAELEMENT type.) Constant numbers may be
       used in places of aliases.
       Allowed types:
       SLHAELEMENT: takes SLHA block name or alias, then set of indices,
                    e.g. SLHAELEMENT[YU, 2, 3]
                    
       Binary operations: all these take 2 aliases as arguments,
                          e.g. DIVIDE[ blah, bloop ] or PLUS[ 2.0, foo ]
       PLUS: adds the arguments
       MINUS: subtracts the 2nd argument from the 1st
       TIMES: multiplies the arguments
       DIVIDE: divides the 1st argument by the 2nd
       POW: raises the 1st argument to the power of the 2nd
       
       Unary operations: all these take 1 alias as the argument,
                         e.g. ATAN[ bar ] or SQRT[ 6 ]
       SQRT: square root
       EXP: e to the power of the argument
       LOG: logarithm in base e
       TAN: tangent
       SIN: sine
       COS: cosine
       TAN: tangent
       ASIN: arcsine (inverse sine)
       ACOS: arccosine (inverse cosine)
       ATAN: arctangent (inverse tangent)
       SINH: hyperbolic sine
       COSH: hyperbolic cosine
       TANH: hyperbolic tangent -->
  <DerivedParameters>
    g1=SLHAELEMENT[g,1]
    ycharmtop=SLHAELEMENT[YU, 2, 3]
    lambda = SLHAELEMENT[ PHIFOURTH, 1 ]
    looplambda = SLHAELEMENT[ LOOPPHIFOURTH, 1 ]
    kappa = SLHAELEMENT[ PHIFOURTH, 2. ]
    deltalambda = MINUS[ looplambda, lambda ]
    tb=SLHAELEMENT[HMIX,2]
    mASq = SLHAELEMENT[HMIX, 4.0]
    beta=ATAN[ tb ]
    cb=COS[ beta ]
    sb=SIN[ beta ]
    sbcb = TIMES[ sb, cb ]
    Bmu=TIMES[ sbcb, mASq ]
    Sqrt2=POW[ 2.0, 0.5 ]
    tbSq=POW[ tb, 2 ]
    tbSqPlusOne=PLUS[ tbSq, 1.0 ]
    sbcbAlt = DIVIDE[tb, tbSqPlusOne]
    oneThird = DIVIDE[1, 3]
    <!-- These examples have varied whitespace and number format conventions,
         just to show what can be interpreted. -->
  </DerivedParameters>
  
  <!-- Non-zero values for fields from FieldVariables should be specified here
       to give the field configuration of the DSB vacuum. Fields not given
       values here will be assumed to be 0 at the DSB minimum. They should be
       given in the form name = value. The values can be given as a sum of
       polynomial terms in the parameters given by DerivedParameters above, and
       also by SLHA block elements with indices in a comma-separated list in
       square brackets after the block name. In effect, they can be given like
       polynomials in the format of TreeLevelPotential below (including raising
       to a power with '^').
       Examples:
       phi = 246.0
       a = HMIX[ 3 ]
       singlet_field=2.0*NMSSMRUN[1]*NMSSMRUN[3] + 1.0 - HMIX[4]
       x = 0.5 * muOverRootLambda (assuming muOverRootLambda was defined in
                                   DerivedParameters above)
       
       Since the values can (and probably will, in general) reference
       scale-dependent parameters, the attribute EvaluationScale can be given
       in GeV with an explicit floating-point number. For example,
       <DsbMinimum EvaluationScale="1.000E+003" >
       as the opening tag will tell VevaciousPlusPlus to evaluate the
       parameters at a scale of 1 TeV. If a scale is not explicitly given,
       the value given by MinimumRenormalizationScale above is used. This only
       affects RgeImprovedOneLoopPotential instances, as
       FixedScaleOneLoopPotential instances consider all parameters to be
       constant over all scales, so leaving EvaluationScale out will still give
       the same values as putting it in (with any value). -->
  <DsbMinimum>
    phi = PHIFOURTHVEVS[ 1 ]
     sigma= 2.0* sbcbAlt * PHIFOURTHVEVS[2] + Sqrt2^2 * I^6 * oneThird
  </DsbMinimum>

</AllowedNonZeroVariables>

<!-- Polynomials (which make up the tree-level potential and also the elements
     of the mass-squared matrices) are always expanded out, have no brackets,
     and are interpreted with the standard operator precedence. Raising x to
     the nth power (where n is a natural number) can be written using a caret:
     x^n, for example. This does not work for constant numbers! Division is not
     possible, unfortunately; none of '/', 'Ö', nor "^-" are permitted: please
     expand out e.g. 4.0/8.0 as 0.5 or use DerivedParameters for such things as
     a ratio of parameters from an SLHA file. -->
<!-- The TreeLevelPotential element should be a polynomial as described above.
     It is used as the tree-level part of the potential energy density
     function. -->
<TreeLevelPotential>
  .25 * lambda * phi^4 - 50e-002 * Bmu * phi^2
  + 0.25 * lambda * sigma^4 + Bmu * sigma^2
  + i^2 * oneThird * kappa * phi^2 * sigma
  <!-- This example has a spurious "i^2" instead of -1, but it works. It's just
       here for testing, but it does maybe allow for automatic model file
       generation without having to worry about whether all factors of i^2 get
       properly written as -1 (also i^4, i^6, etc., are interpreted as +1, -1,
       etc.). (There are 4 characters that are interpreted as the imaginary
       unit: 'i', 'I', 'j', and 'J'.) However, the tree-level potential should
       be real and written entirely in terms of real components, with complex
       terms expanded out. Also, the way in which floating-point numbers are
       written is also deliberately inconsistent, to demonstrate allowed
       conventions. -->
</TreeLevelPotential>

<!-- The loop corrections come in 2 forms: an additional polynomial in the same
     form as the tree-level potential above (which allows Lagrangian parameters
     to be given as expansions in h-bar), and sets of mass or mass-squared
     matrices.
     
     There is so far only 1 attribute that needs to be given:
     RenormalizationScheme, which can be "MSBAR" or "DRBAR", but the
     renormalization scheme does not have to be strictly MS-bar or DR-bar.
     The regularization is assumed to be dimensional, taking care of the
     divergences, while a loop expansion of the finite parts of the Lagrangian
     parameters can be accommodated with ExtraPolynomialPart, which is added
     as a 1-loop correction to TreeLevelPotential. All that (currently) is
     decided by RenormalizationScheme is whether vector degrees of freedom with
     mass m contribute m^4 (ln[m^2/Q^2] - 5/6) by giving "MSBAR" or instead
     m^4 (ln[m^2/Q^2] - 3/2) by giving "DRBAR" (taking into account the
     "epsilon scalars" of softly-broken supersymmetric models in the "modified
     DR-bar" scheme of Stephen P. Martin, Phys.Rev. D65 (2002) 116003
     http://arxiv.org/abs/hep-ph/0111209). -->
<LoopCorrections RenormalizationScheme="MSBAR" GaugeFixing="LANDAU" >

  <!-- Finite loop corrections of the same form as the tree-level potential can
       be given with ExtraPolynomialPart, which is given in the same format as
       TreeLevelPotential above. -->
  <ExtraPolynomialPart>
    .25e-00 * deltalambda * phi^4 + 2.0E-1 * unknown[ 1, 2, 3 ] * phi^2
    + 0.25 * looplambda * anotherField^4
    <!-- There is a "variable" here called "unknown[ 1, 2, 3 ]" which was not
         specified in AllowedNonZeroVariables above, so it is treated as an
         alias for 0, and likewise for "anotherField". If anotherField were to
         be added to FieldVariables, it would be treated as a field here as
         expected. -->
  </ExtraPolynomialPart>

  <!-- Currently, bosonic degrees of freedom (real scalars and real vectors)
       should have their real tree-level masses-squared matrices given by
       RealBosonMassSquaredMatrix elements, while Weyl fermion degrees of
       freedom should have their (possibly) complex mass matrices given by
       WeylFermionMassMatrix elements.
       
       Each matrix is actually given as a newline-separated list of the
       elements, in the order of all the elements of the 1st row followed by
       all the elements of the 2nd row and so on. (Since only the eigenvalues
       are sought, it doesn't actually matter if the transpose is given.) Both
       the bosonic mass-squared matrices and the squares of the fermionic mass
       matrices are assumed to be self-adjoint.
       
       Each element of a mass or mass-squared matrix is in the same format as
       the polynomial parts of the potential.
       
       Each RealBosonMassSquaredMatrix and each WeylFermionMassMatrix must have
       (currently) 2 attributes:
       SpinType which can have the values "ScalarBoson", "WeylFermion", or
       "GaugeBoson" (as each of the types has a unique way of contributing to
       the loop corrections); and
       MultiplicityFactor, which should have positive integer values (allowing
       for symmetric copies of mass eigenstates to be calculated more quickly,
       such as the 3 copies of each quark if there are no colored scalars which
       could break SU(3)_c with non-zero field values), which defaults to "1".
       
       The tree-level masses-squared are used for both the zero-temperature
       1-loop corrections and the thermal corrections. Note that scalar boson
       mass-squared matrices are NOT automatically generated by the code
       differentiating the tree-level potential, they MUST be given explicitly
       through a RealBosonMassSquaredMatrix. -->
       
  <RealBosonMassSquaredMatrix SpinType="ScalarBoson" MultiplicityFactor="1" >
    12.0 * g1^2 * phi^2 - 2.0 * Bmu
  </RealBosonMassSquaredMatrix>
  
  <!-- This is a toy analogue of the mass matrix for the vector of Weyl
       fermions ( charm_L, charm_R^c, top_L, top_R^c ) -->
  <WeylFermionMassMatrix SpinType="WeylFermion" MultiplicityFactor="3" >
    0.0
    y[ 2, 2 ] * phi + i * IMYU[ 2, 2 ] * phi
    0.0
    y[ 2, 3 ] * phi + I * IMYU[ 2, 3 ] * phi
    y[ 2, 2 ] * phi + i * IMYU[ 2, 2 ] * phi
    0.0
    ycharmtop * phi + I * IMYU[ 2, 3 ] * phi
    0.0
    0.0
    y[ 3, 2 ] * phi + j * IMYU[ 3, 2 ] * phi
    0.0
    y[ 3, 3 ] * phi + J * IMYU[ 3, 3 ] * phi
    y[ 3, 2 ] * phi + j * IMYU[ 3, 2 ] * phi
    0.0
    y[ 3, 3 ] * phi + J * IMYU[ 3, 3 ] * phi
    0.0
  </WeylFermionMassMatrix>

  <ComplexWeylFermionMassSquaredMatrix
   SpinType="WeylFermion" MultiplicityFactor="3" >
    y[ 2, 2 ] * phi + i * IMYU[ 2, 2 ] * phi
    y[ 2, 3 ] * phi + I * IMYU[ 2, 3 ] * phi
    y[ 3, 2 ] * phi + j * IMYU[ 3, 2 ] * phi
    y[ 3, 3 ] * phi + J * IMYU[ 3, 3 ] * phi
  </ComplexWeylFermionMassSquaredMatrix>
  
  <RealBosonMassSquaredMatrix SpinType="GaugeBoson" MultiplicityFactor="1" >
    Sqrt2^2 * 0.25 * g[1]^2 * phi^2
  </RealBosonMassSquaredMatrix>

</LoopCorrections>

</VevaciousModelFile>