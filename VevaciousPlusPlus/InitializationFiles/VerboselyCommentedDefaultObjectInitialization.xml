<VevaciousPlusPlusObjectInitialization>

<!--
#  VevaciousPlusPlusObjectInitialization.xml
#
#  Created on: Apr 10, 2014
#      Author: Ben O'Leary (benjamin.oleary@gmail.com)
#      Copyright 2014 Ben O'Leary
#
#      This file is part of VevaciousPlusPlus, released under the
#      GNU General Public License. Please see the accompanying
#      README.VevaciousPlusPlus.txt file for a full list of files, brief
#      documentation on how to use these classes, and further details on the
#      license.
#
 -->

<!-- Quick start: if you just want to change the model (i.e. the potential in
     terms of a set of fields), change
     <PotentialClass><ConstructorArguments><ModelFile> to the name of the file
     with the model in it (such as ./ModelFiles/TwoHiggsDoublet.vin or
     ./ModelFiles/RestrictedToRealVevsRealMssm.vin). Almost everything else is
     for tweaking the way in which the (meta)stability is calculated, such as
     the resolution of the tunneling path, or whether thermal tunneling is
     skipped, and so on. -->
 
  <PotentialClass>
    <!-- Currently <ClassType> must be either "FixedScaleOneLoopPotential" or
         "RgeImprovedOneLoopPotential". Both are classes that construct the
         potential energy density from a tree-level polynomial with one-loop
         corrections in the form of a polynomial of finite parts of
         counterterms along with the usual corrections from mass-squared
         eigenvalues in form m^4 ( ln[m^2/Q^2] - constant ), and thus both need
         <ConstructorArguments> to give the model file in <ModelFile>.
         Optionally, whether or not tree-level saddle points and maxima can be
         used as valid starting points for gradient-based minimization can be
         set in <RollOnlyMinima> within <ConstructorArguments> (defaulting to
         false). -->
    <ClassType>
      FixedScaleOneLoopPotential
    </ClassType>
    <ConstructorArguments>
      <ModelFile>
        <!-- /home/bol/BOL/Cplusplus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin -->
        <!-- /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/RestrictedToRealVevsRealMssm.vin -->
        /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin
      </ModelFile>
      <RollOnlyMinima>
        <!-- Either "true"/"yes" or "false"/"no" (case-insensitive): if true
             then the starting points for gradient-based minimization are only
             the subset of solutions from the homotopy continuation solutions
             which also are minima of the tree-level potential (so discarding
             tree-level maxima and saddle points). This should only be used if
             you are sure that the tree-level minima suffice to find every
             one-loop minimum by following the steepest descent, and it will
             only speed up this part of the run, while under usual
             circumstances it is the tunneling calculation which is the
             bottleneck. -->
        true
      </RollOnlyMinima>
      <ScaleRangeMinimumFactor>
      <!-- Another option: the maximum scale is at least the minimum scale in
           the SLHA file multiplied by the number given here. For example, if
           this number were 10.0, and the SLHA file had blocks at Q= 246.0 up
           to Q= 1000.0, the maximum scale would be pushed up to 2460.0; in
           contrast, if the number here were 2.0, the maximum scale would
           remain 1000.0 as opposed to 2.0 * 246.0 = 492.0 (for purposes of
           restricting Minuit2 from rolling too far away from the region of
           validity, for example).
        10.0
      </ScaleRangeMinimumFactor>
    </ConstructorArguments>
  </PotentialClass>
  
  <MinimizerClass>
    <!-- Currently <ClassType> must be "GradientFromStartingPoints", and
         <ConstructorArguments> must give the <StartingPointFinderClass> and
         <GradientMinimizerClass> components. Optional elements
         <ExtremumSeparationThresholdFraction> and
         <NonDsbRollingToDsbScalingFactor> may also be given. -->
    <ClassType>
      GradientFromStartingPoints
    </ClassType>
    <ConstructorArguments>
      <StartingPointFinderClass>
        <!-- Currently <ClassType> must be "Hom4ps2Runner", and
             <ConstructorArguments> must give the path to the directory with
             the hom4ps2 executable by <PathToHom4ps2> and the argument for the
             executable by <Hom4ps2Argument>. -->
        <ClassType>
          Hom4ps2Runner
        </ClassType>
        <ConstructorArguments>
          <PathToHom4ps2>
            <!-- /home/bol/BOL/machine-specific/HOM4PS2/ -->
            /Users/oleary/BOL/machine-specific/HOM4PS2/
          </PathToHom4ps2>
          <Hom4ps2Argument>
            <!-- The argument for HOM4PS2, as prompted by HOM4PS2:
                 "Please enter the option of homotopy method
                    1. The polyhedral homotopy
                    2. The classical linear homotopy"
                 1 can be faster for systems of many variables,
                 but 2 seems more reliable. -->
            2
          </Hom4ps2Argument>
        </ConstructorArguments>
      </StartingPointFinderClass>
      <GradientMinimizerClass>
        <!-- Currently <ClassType> must be "MinuitPotentialMinimizer" and
             <ConstructorArguments> must have <MinimaSeparationThreshold>. -->
        <ClassType>
          MinuitPotentialMinimizer
        </ClassType>
        <ConstructorArguments>
          <!-- The initial step sizes for Minuit2 will be equal to the
               starting point scaled by the number given in
               <InitialStepSizeFraction>, or equal to the number given in
               <MinimumInitialStepSize>, whichever is larger (so a starting
               value of 0 will still have an initial step size given by the
               number in <MinimumInitialStepSize>, for example). -->
          <InitialStepSizeFraction>
            0.1
          </InitialStepSizeFraction>
          <MinimumInitialStepSize>
            1.0
          </MinimumInitialStepSize>
          <MinuitStrategy>
            <!-- The number given here is given to Minuit2 to decide how
                 precise it tries to be, through more or less calls of the
                 function to be minimized. The default is 1, while 0 emphasizes
                 making less function calls, and 2 emphasizes more accuracy
                 through more function calls. -->
            1
          </MinuitStrategy>
        </ConstructorArguments>
      </GradientMinimizerClass>
      <ExtremumSeparationThresholdFraction>
        <!-- The number given here is used as a threshold for ensuring that
             the same minimum rolled to from separate starting points is
             treated as the same minimum even if the minimizations did not lead
             to exactly the same numbers for the values of the fields. If the
             shorter of the Euclidean lengths of the 2 vectors in field space
             describing the minima is l, and the Euclidean length of the
             difference is d, and the number given by this element is f, then
             2 minima are treated as the same minimum if d < (f * l). If not
             given, 0.05 is taken as the default. -->
        0.05
      </ExtremumSeparationThresholdFraction>
      <NonDsbRollingToDsbScalingFactor>
        <!-- The number given here is used as a scaling factor if the minimum
             is suspected of being the result of some unfortunate shifting of
             basins of attraction: we discovered in explorations with
             Vevacious 1 that it could happen that the basin of attraction of
             the DSB minimum at 1-loop level could grow so large that it would
             encompass tree-level minima that belong in some sense to other
             1-loop minima, which moved very far away due to loop corrections,
             so even though their basins of attraction also grew very large in
             the same way that of the DSB minimum did, they moved enough that
             "their" tree-level minima were left out. If a starting point is
             sufficiently far away from the DSB minimum yet rolls there under
             gradient-based minimization, the starting point's field values are
             scaled up by the number given by this element, and used as a new
             starting point. If not given, 10.0 is taken as the default. -->
        10.0
      </NonDsbRollingToDsbScalingFactor>
    </ConstructorArguments>
  </MinimizerClass>
  
  <TunnelingClass>
    <!-- Currently <ClassType> must be either "BounceAlongPathWithThreshold" or
         "CosmoTransitionsRunner", both needing <ConstructorArguments> to have
         child elements <TunnelingStrategy> and <SurvivalProbabilityThreshold>.
         If <ClassType> is "CosmoTransitionsRunner", then
         <ConstructorArguments> must also give the path to the CosmoTransitions
         directory (where pathDeformation.py is) by <PathToCosmotransitions>,
         while "BounceAlongPathWithThreshold" needs <BouncePotentialFit> and
         <BouncePathFinder>. -->
    <ClassType>
      MinuitBounceActionMinimizer
    </ClassType>
    <ConstructorArguments>
      <TunnelingStrategy>
        <!-- Valid options: "NoTunneling", "JustQuantum", "JustThermal",
                            "ThermalThenQuantum", or "QuantumThenThermal"
             (no quote marks in actual element). -->
        JustQuantum
      </TunnelingStrategy>
      <SurvivalProbabilityThreshold>
        0.01
      </SurvivalProbabilityThreshold>
      <CriticalTemperatureAccuracy>
        <!-- This option gives the accuracy to which the critical and
             evaporation temperatures will be calculated if necessary, in that
             the temperature used will be within 2^-(the number given here) of
             the exact value. -->
        7
      </CriticalTemperatureAccuracy>
      <EvaporationBarrierResolution>
        <!-- This option gives the resolution of the energy barrier between the
             field configuration of the DSB vacuum at zero temperature and the
             field origin, which is evaluated at different temperatures to see
             if there is a positive energy barrier: if not, the DSB vacuum is
             deemed to have "evaporated" and tunneling out of the DSB vacuum is
             substituted with tunneling out of the field origin. -->
        3
      </EvaporationBarrierResolution>
      <!-- The following elements are read only if <ClassType> is
           "CosmoTransitionsRunner", and are ignored if <ClassType> is
           "BounceAlongPathWithThreshold". -->
      <PathToCosmotransitions>
        /Users/oleary/BOL/machine-specific/CosmoTransitions2/
      </PathToCosmotransitions>
      <PathResolution>
        <!-- This is the number of nodes along the path between the false
             vacuum and the true vacuum that CosmoTransitions uses. If not
             given, 100 is used as the default. -->
        100
      </PathResolution>
      <MaxInnerLoops>
        <!-- This is the number of iterations of the inner loop that
             CosmoTransitions is allowed. The inner loop adjusts the path along
             the normal force directions. If not given, 10 is used as the
             default. -->
        10
      </MaxInnerLoops>
      <MaxOuterLoops>
        <!-- This is the number of iterations of the outer loop that
             CosmoTransitions is allowed. The outer loop adjusts the
             1-dimensional bounce action along the path then runs the inner
             loop. If not given, 10 is used as the default. -->
        10
      </MaxOuterLoops>
      <!-- End of set of elements only read if <ClassType> is
           "CosmoTransitionsRunner". -->
      <!-- The following elements are read only if <ClassType> is
           "BounceAlongPathWithThreshold", and are ignored if <ClassType> is
           "CosmoTransitionsRunner". -->
      <ThermalIntegrationResolution>
        <!-- This is the number of temperatures summed over for thermal decay
             width integrations. -->
        5
      </ThermalIntegrationResolution>
      <BouncePotentialFit>
        <!-- Currently the only valid option for <ClassType> is
             "BubbleShootingOnSpline", which implements the Coleman
             undershoot-overshoot method on a tunneling path from the true
             vacuum to the false vacuum, parameterizing the potential along the
             tunneling path by a fit to a set of potential energy densities at
             a set of values for the path parameterization variable. The number
             of nodes for this fit is given by
             <ConstructorArguments><NumberOfNodesForPotentialFit> (excluding
             the false vacuum and true vacuum, so if "3" were given, the
             potential would be fitted to 5 points: the false vacuum, the true
             vacuum, and 3 intermediate points).
             
             Currently, the way the potential is interpolated is fixed to being
             approximated as quadratic polynomials between nodes, with
             continuous slope between the spline segments. The first and last
             spline segments (i.e. each segment with a vacuum at one end) are
             taken as being in the form p^2 + const, where p is the distance
             from the vacuum end of the segment in the path parameterization
             variable, so the vacua are proper minima. Unfortunately it is
             crucial that the approximation in the neighborhoods of a vacuum
             has the properties that the slope vanishes exactly at the vacuum,
             decreasing monotonically as the distance from the vacuum
             decreases, and that very small distances from the vacuum are
             resolved precisely. If not, the undershoot/overshoot method
             implemented in VevaciousPlusPlus will break down, as the
             "particle rolling from one hill to another" might get stuck close
             to the true vacuum if the slope resolves to zero instead of
             10^-16, for example. A polynomial of degree
             NumberOfNodesForPotentialFit really failed in our test cases where
             the bubble would have a thin wall, as did quadratic splines
             without the extra care to have special cases for the first and
             last segments. -->
        <ClassType>
          BubbleShootingOnSpline
        </ClassType>
        <ConstructorArguments>
          <NumberOfNodesForPotentialFit>
            100
          </NumberOfNodesForPotentialFit>
          <NumberShootAttemptsAllowed>
            <!-- This is the number of shoot attempts allowed to try to find
                 the perfect shot before moving on with the best shot so far to
                 calculate the bounce action. -->
            32
          </NumberShootAttemptsAllowed>
          <RadialResolution>
            <!-- The initial step size in 1/GeV for numerically integrating the
                 bubble's equations of motion is given by the number given here
                 divided by the largest energy scale from the potential (from
                 among the Euclidean lengths of the vacua and the tunneling
                 scale given by the PotentialFunction object). -->
            0.05
          </RadialResolution>
        </ConstructorArguments>
      </BouncePotentialFit>
      <TunnelPathFinder>
        <ClassType>
        <!-- The valid options for this version of VevaciousPlusPlus are:
             "MinuitPathBounceMinimizer" (minimizing the bounce action along
             the tunneling path directly),
             "MinuitPathPotentialMinimizer" (minimizing the sum of values of
             the potential over a set of points along the tunneling path), or
             "MinuitNodePotentialMinimizer" (minimizing the potential over a
             set of points along the tunneling path on a node-by-node basis.
             Both "MinuitPathPotentialMinimizer" and
             "MinuitNodePotentialMinimizer" are close to the algorithm followed
             by CosmoTransitions. The difference between
             "MinuitPathPotentialMinimizer" and "MinuitNodePotentialMinimizer"
             is that the former can take a path parameterized in such a way
             that varying any parameter affects the whole path, while the
             latter requires that varying any parameter only varies the path in
             a very localized region, so that the sampled potential values are
             independent. The advantage of the latter is that it then reduces
             the minimization in an (n*f)-dimensional space, where there are n
             nodes with f free parameters per node, to n independent
             minimizations in an f-dimensional space. If using
             "MinuitNodePotentialMinimizer", <ConstructorArguments> here must
             have "LinearSplineThroughNodes", "QuadraticSplineThroughNodes", or
             "PolynomialThroughNodes" in <PathParameterization><ClassType>.
             (There is a good reason why there is no option to have a
             "MinuitNodeBounceMinimizer": calculating the bounce action
             requires knowing the whole path, so there is nothing to be gained
             by looking at a single node at a time, and Minuit2 will vary each
             node on its own anyway as part of the process of varying the whole
             path.) -->
          MinuitNodePotentialMinimizer
        </ClassType>
        <ConstructorArguments>
          <MovesPerImprovement>
            <!-- If using "MinuitPathBounceMinimizer" or
                 "MinuitPathPotentialMinimizer", this is the number of function
                 calls that Minuit2 is allowed to make to improve the path
                 before the bounce action along the path is checked against the
                 threshold. If using "MinuitNodePotentialMinimizer", this gives
                 the number of moves per node used by a single iterator of path
                 improvement (before checking to see if the action has dropped
                 below the threshold). -->
            100
          </MovesPerImprovement>
          <MinuitStrategy>
            <!-- The number given here is given to Minuit2 to decide how
                 precise it tries to be, through more or less calls of the
                 function to be minimized. The default is 1, while 0 emphasizes
                 making less function calls, and 2 emphasizes more accuracy
                 through more function calls. -->
            1
          </MinuitStrategy>
          <MinuitTolerance>
            <!-- The number given here is a fraction to multiply Minuit2's
                 default 0.001 to yield the tolerance fraction, which is the
                 fraction of the value of the function at a point which is
                 used to compare to the estimated ("vertical") distance to the
                 minimum. For example, if 0.5 is given, then as soon as Minuit2
                 estimates that it is at a point with function value within
                 0.0005 of what it estimates is the value at the minimum, it
                 considers its minimization complete. -->
            0.1
          </MinuitTolerance>
          <NumberOfPotentialSamplePoints>
            <!-- If using "MinuitPathPotentialMinimizer", this gives the number
                 of nodes at which the potential will be evaluated for the sum,
                 though if <PathParameterization> has a larger number in
                 <ConstructorArguments><NumberOfVaryingNodes>, that will be
                 used instead. If using "MinuitNodePotentialMinimizer" or
                 "MinuitPathBounceMinimizer", this number is ignored, as the
                 number of nodes will be taken from
                 <ConstructorArguments><NumberOfVaryingNodes> in
                 <PathParameterization>
                 or <BouncePotentialFit><NumberOfNodesForPotentialFit> in
                 <BouncePotentialFit> within
                 <TunnelPathFinder><ConstructorArguments> (not the XML element
                 within <TunnelingClass><ConstructorArguments>). -->
            15
          </NumberOfPotentialSamplePoints>
          <BouncePotentialFit>
            <!-- This is used by "MinuitPathBounceMinimizer" and is ignored by
                 the other options. It has the same possibilities as the
                 element of the same name under
                 <TunnelingClass><ConstructorArguments>. The numbers given here
                 allow for the path finding code to use a lower-resolution
                 version to try to find the path more quickly while still
                 allowing an accurate evaluation of the bounce action along the
                 final path. -->
            <ClassType>
              BubbleShootingOnSpline
            </ClassType>
            <ConstructorArguments>
              <NumberOfNodesForPotentialFit>
                8
              </NumberOfNodesForPotentialFit>
              <NumberShootAttemptsAllowed>
                16
              </NumberShootAttemptsAllowed>
              <RadialResolution>
                0.05
              </RadialResolution>
            </ConstructorArguments>
          </BouncePotentialFit>
          <PathParameterization>
            <ClassType>
              <!-- The valid options for this version of VevaciousPlusPlus are:
                   "PathFromNodes" or "PathFromPolynomialCoefficients". The
                   parameterization of the first is that the parameterization
                   sets up a set of nodes in field space between the vacua,
                   then a parameterization of the fields which goes through the
                   nodes from the false vacuum to the true vacuum is generated
                   as the tunneling path. The parameterization of the second is
                   that the field with greatest difference between the vacua is
                   chosen as a reference and then parameterized as a constant
                   plus a linear term in a path auxiliary variable, and the
                   other fields are parameterized as polynomials in the path
                   auxiliary. The coefficients are given in sets of
                   (number of fields - 1) for the varying fields, each set
                   corresponding to a higher power of the path auxiliary. For
                   example, if there are 4 varying fields, then the
                   parameterization is a vector of sets of 3 coefficients, the
                   first 3 being the quadratic coefficients, the 2nd 3 being
                   the cubic coefficients, and so on, until each field has
                   NumberOfCoefficientsPerVaryingField coefficients. -->
              PathFromNodes
            </ClassType>
            <ConstructorArguments>
              <NumberOfCoefficientsPerVaryingFieldBeyondLinear>
                <!-- This is only used by "PathFromPolynomialCoefficients", and
                     is ignored by "PathFromNodesOnParallelPlanes" and
                     "PathFromNodesOnBisectingPlanes". It is the number of
                     coefficients for terms with powers of the path auxiliary
                     variable above 1. For example, 3 here would mean that each
                     field would be parameterized as a polynomial of degree 4:
                     c_0 + c_1 p + c_2 p^2 + c_3 p^3 + c_4 p^4, except for the
                     reference field, which is the field with largest
                     difference between values at the true vacuum and the false
                     vacuum, which is always held to a linear function of p
                     (if it were allowed to be the same degree as the other
                     fields, there would be an infinite degeneracy in path
                     parameterizations along the lines of this example: all
                     fields with the only non-zero coefficients being the
                     constant term and the quadratic term gives exactly the
                     same path as only the constant and the linear term being
                     non-zero, and so on, as the ratio of the fields is the
                     same in each case). -->
                3
              </NumberOfCoefficientsPerVaryingField>
              <NumberOfVaryingNodes>
                <!-- This is only used by "PathFromNodesOnParallelPlanes" and
                     "PathFromNodesOnBisectingPlanes", and is ignored by
                     "PathFromPolynomialCoefficients". This is taken as a lower
                     bound by "PathFromNodesOnBisectingPlanes", as it requires
                     a number that is one less than an integer power of two
                     (so: 1, 3, 7, 15, 31, ...) and the lowest (2^n)-1 >= the
                     number given here will be taken. -->
                7
              </NumberOfVaryingNodes>
              <NodeParameterizationStyle>
                <!-- This is only used by "PathFromNodes" and is ignored by
                     "PathFromPolynomialCoefficients".
                     The current valid options are "NodesOnParallelPlanes" or
                     "NodesOnBisectingPlanes". Both take the field with
                     greatest difference between the false vacuum and true
                     vacuum as the reference field, and each node is
                     parameterized as a vector in the hyperplane where the
                     reference field has zero value. If using
                     "NodesOnParallelPlanes", that vector is then projected
                     to be perpendicular to a vector going from false vacuum to
                     true vacuum, and then the node gets a multiple of that
                     vector, so the nodes end up on a series of parallel planes
                     between the vacua. The procedure if using
                     "NodesOnBisectingPlanes" is similar, except the planes are
                     those that bisect the vector between nodes: first a node
                     on a plane bisecting the vector between the vacua is
                     calculated, then a node between that node and the false
                     vacuum is calculated such that it lies on a plane
                     perpendicular to the vector from the false vacuum to the
                     node just calculated, and another node between the node
                     just calculated and the true vacuum in a similar manner is
                     calculated. Also, since the vector between nodes may end
                     up on the parameterized node plane, the nodes are rotated
                     to be perpendicular rather than projected (in general
                     there are many possible rotations: here a consistent set
                     of orthogonal vectors is built from the vector between the
                     nodes, taking initially the first two non-reference fields
                     and making them orthogonal to the vector, with the rest of
                     the components set to zero, then another vector orthogonal
                     to both vectors is taken with the third non-reference
                     field, keeping the remaining components non-zero, and so
                     on. -->
                NodesOnParallelPlanes
              </NodeParameterizationStyle>
              <InterpolationStyle>
                <!-- This is only used by "PathFromNodes" and is ignored by
                     "PathFromPolynomialCoefficients".
                     The valid options for this version of VevaciousPlusPlus
                     are:
                     "PolynomialPath" (a single polynomial fit of degree (n+1),
                     with n = the number given by NumberOfVaryingNodes),
                     "LinearSplinePath" (approximated as a straight line
                     between the nodes), or
                     "QuadraticSplinePath" (approximated as quadratic
                     polynomials between nodes, with continuous slope between
                     the spline segments; the first segment is taken as linear
                     and each subsequent segment is constructed to have slope
                     continuous with its previous segment).
                     Unfortunately, "PolynomialPath" performs poorly, as it
                     tends to make very wiggly paths which leads to very high
                     bounce actions due to the derivative term, so it is NOT
                     recommended! -->
                LinearSplinePath
              </InterpolationStyle>
            </ConstructorArguments>
          </PathParameterization>
          <NodeMovementThreshold>
            0.01
          </NodeMovementThreshold>
        </ConstructorArguments>
      </TunnelPathFinder>
      <!-- End of set of elements only read if <ClassType> is
           "BounceAlongPathWithThreshold". -->
    </ConstructorArguments>
  </TunnelingClass>

</VevaciousPlusPlusObjectInitialization>

