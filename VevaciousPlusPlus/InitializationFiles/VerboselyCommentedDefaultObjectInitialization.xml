<VevaciousPlusPlusObjectInitialization>

<!--
#  VevaciousPlusPlusObjectInitialization.xml
#
#  Created on: Apr 10, 2014
#      Author: Ben O'Leary (benjamin.oleary@gmail.com)
#      Copyright 2014 Ben O'Leary
#
#      This file is part of VevaciousPlusPlus, released under the
#      GNU General Public License. Please see the accompanying
#      README.VevaciousPlusPlus.txt file for a full list of files, brief
#      documentation on how to use these classes, and further details on the
#      license.
#
 -->

<!-- Quick start: if you just want to change the model (i.e. the potential in
     terms of a set of fields), change
     <PotentialClass><ConstructorArguments><ModelFile> to the name of the file
     with the model in it (such as ./ModelFiles/TwoHiggsDoublet.vin or
     ./ModelFiles/RestrictedToRealVevsRealMssm.vin). Almost everything else is
     for tweaking the way in which the (meta)stability is calculated, such as
     the resolution of the tunneling path, or whether thermal tunneling is
     skipped, and so on. -->
 
  <PotentialClass>
    <!-- Currently <ClassType> must be either "FixedScaleOneLoopPotential" or
         "RgeImprovedOneLoopPotential". Both are classes that construct the
         potential energy density from a tree-level polynomial with one-loop
         corrections in the form of a polynomial of finite parts of
         counterterms along with the usual corrections from mass-squared
         eigenvalues in form m^4 ( ln[m^2/Q^2] - constant ), and thus both need
         <ConstructorArguments> to give the model file in <ModelFile>.
         Optionally, whether or not tree-level saddle points and maxima can be
         used as valid starting points for gradient-based minimization can be
         set in <RollOnlyMinima> within <ConstructorArguments> (defaulting to
         false). -->
    <ClassType>
      FixedScaleOneLoopPotential
    </ClassType>
    <ConstructorArguments>
      <ModelFile>
        <!-- /home/bol/BOL/Cplusplus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin -->
        <!-- /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/RestrictedToRealVevsRealMssm.vin -->
        /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin
      </ModelFile>
      <RollOnlyMinima>
        <!-- Either "true"/"yes" or "false"/"no" (case-insensitive): if true
             then the starting points for gradient-based minimization are only
             the subset of solutions from the homotopy continuation solutions
             which also are minima of the tree-level potential (so discarding
             tree-level maxima and saddle points). This should only be used if
             you are sure that the tree-level minima suffice to find every
             one-loop minimum by following the steepest descent, and it will
             only speed up this part of the run, while under usual
             circumstances it is the tunneling calculation which is the
             bottleneck. -->
        true
      </RollOnlyMinima>
      <ScaleRangeMinimumFactor>
      <!-- Another option: the maximum scale is at least the minimum scale in
           the SLHA file multiplied by the number given here. For example, if
           this number were 10.0, and the SLHA file had blocks at Q= 246.0 up
           to Q= 1000.0, the maximum scale would be pushed up to 2460.0; in
           contrast, if the number here were 2.0, the maximum scale would
           remain 1000.0 as opposed to 2.0 * 246.0 = 492.0 (for purposes of
           restricting Minuit2 from rolling too far away from the region of
           validity, for example).
        10.0
      </ScaleRangeMinimumFactor>
    </ConstructorArguments>
  </PotentialClass>
  
  <MinimizerClass>
    <!-- Currently <ClassType> must be "GradientFromStartingPoints", and
         <ConstructorArguments> must give the <StartingPointFinderClass> and
         <GradientMinimizerClass> components. Optional elements
         <ExtremumSeparationThresholdFraction> and
         <NonDsbRollingToDsbScalingFactor> may also be given. -->
    <ClassType>
      GradientFromStartingPoints
    </ClassType>
    <ConstructorArguments>
      <StartingPointFinderClass>
        <!-- Currently <ClassType> must be "Hom4ps2Runner", and
             <ConstructorArguments> must give the path to the directory with
             the hom4ps2 executable by <PathToHom4ps2> and the argument for the
             executable by <Hom4ps2Argument>. -->
        <ClassType>
          Hom4ps2Runner
        </ClassType>
        <ConstructorArguments>
          <PathToHom4ps2>
            <!-- /home/bol/BOL/machine-specific/HOM4PS2/ -->
            /Users/oleary/BOL/machine-specific/HOM4PS2/
          </PathToHom4ps2>
          <Hom4ps2Argument>
            <!-- The argument for HOM4PS2, as prompted by HOM4PS2:
                 "Please enter the option of homotopy method
                    1. The polyhedral homotopy
                    2. The classical linear homotopy"
                 1 can be faster for systems of many variables,
                 but 2 seems more reliable. -->
            2
          </Hom4ps2Argument>
        </ConstructorArguments>
      </StartingPointFinderClass>
      <GradientMinimizerClass>
        <!-- Currently <ClassType> must be "MinuitPotentialMinimizer" and
             <ConstructorArguments> must have <MinimaSeparationThreshold>. -->
        <ClassType>
          MinuitPotentialMinimizer
        </ClassType>
        <ConstructorArguments>
          <!-- The initial step sizes for Minuit2 will be equal to the
               starting point scaled by the number given in
               <InitialStepSizeFraction>, or equal to the number given in
               <MinimumInitialStepSize>, whichever is larger (so a starting
               value of 0 will still have an initial step size given by the
               number in <MinimumInitialStepSize>, for example). -->
          <InitialStepSizeFraction>
            0.1
          </InitialStepSizeFraction>
          <MinimumInitialStepSize>
            1.0
          </MinimumInitialStepSize>
          <MinuitStrategy>
            <!-- The number given here is given to Minuit2 to decide how
                 precise it tries to be, through more or less calls of the
                 function to be minimized. The default is 1, while 0 emphasizes
                 making less function calls, and 2 emphasizes more accuracy
                 through more function calls. -->
            1
          </MinuitStrategy>
        </ConstructorArguments>
      </GradientMinimizerClass>
      <ExtremumSeparationThresholdFraction>
        <!-- The number given here is used as a threshold for ensuring that
             the same minimum rolled to from separate starting points is
             treated as the same minimum even if the minimizations did not lead
             to exactly the same numbers for the values of the fields. If the
             shorter of the Euclidean lengths of the 2 vectors in field space
             describing the minima is l, and the Euclidean length of the
             difference is d, and the number given by this element is f, then
             2 minima are treated as the same minimum if d < (f * l). If not
             given, 0.05 is taken as the default. -->
        0.05
      </ExtremumSeparationThresholdFraction>
      <NonDsbRollingToDsbScalingFactor>
        <!-- The number given here is used as a scaling factor if the minimum
             is suspected of being the result of some unfortunate shifting of
             basins of attraction: we discovered in explorations with
             Vevacious 1 that it could happen that the basin of attraction of
             the DSB minimum at 1-loop level could grow so large that it would
             encompass tree-level minima that belong in some sense to other
             1-loop minima, which moved very far away due to loop corrections,
             so even though their basins of attraction also grew very large in
             the same way that of the DSB minimum did, they moved enough that
             "their" tree-level minima were left out. If a starting point is
             sufficiently far away from the DSB minimum yet rolls there under
             gradient-based minimization, the starting point's field values are
             scaled up by the number given by this element, and used as a new
             starting point. If not given, 4.0 is taken as the default. -->
        4.0
      </NonDsbRollingToDsbScalingFactor>
    </ConstructorArguments>
  </MinimizerClass>
  
  <TunnelingClass>
    <!-- Currently <ClassType> must be either "BounceAlongPathWithThreshold" or
         "CosmoTransitionsRunner", both needing <ConstructorArguments> to have
         child elements <TunnelingStrategy> and <SurvivalProbabilityThreshold>.
         If <ClassType> is "CosmoTransitionsRunner", then
         <ConstructorArguments> must also give the path to the CosmoTransitions
         directory (where pathDeformation.py is) by <PathToCosmotransitions>,
         while "BounceAlongPathWithThreshold" needs <BouncePotentialFit> and
         <BouncePathFinder>. -->
    <ClassType>
      BounceAlongPathWithThreshold
    </ClassType>
    <ConstructorArguments>
      <TunnelingStrategy>
        <!-- Valid options: "NoTunneling", "JustQuantum", "JustThermal",
                            "ThermalThenQuantum", or "QuantumThenThermal"
             (no quote marks in actual element). -->
        JustQuantum
      </TunnelingStrategy>
      <SurvivalProbabilityThreshold>
        0.01
      </SurvivalProbabilityThreshold>
      <ThermalActionResolution>
      <!-- This is the number of temperatures taken for the thermal bounce
           action calculation. If using "CosmoTransitionsRunner", the thermal
           bounce actions with a straight path is sampled at this many
           temperatures (equally spaced) and then used to estimate the thermal
           dependence of the bounce action, which is then used to estimate the
           temperature which dominates thermal tunneling, which is then used
           for the full calculation by CosmoTransitions. If using
           "BounceAlongPathWithThreshold", the integration of the decay width
           over temperature is performed by a numerical approximation summing
           over this many temperatures (equally spaced). -->
        5
      </ThermalActionResolution>
      <CriticalTemperatureAccuracy>
        <!-- This option gives the accuracy to which the critical and
             evaporation temperatures will be calculated if necessary, in that
             the temperature used will be within 2^-(the number given here) of
             the exact value. -->
        7
      </CriticalTemperatureAccuracy>
      <!-- The following elements are read only if <ClassType> is
           "CosmoTransitionsRunner", and are ignored if <ClassType> is
           "BounceAlongPathWithThreshold". -->
      <PathToCosmotransitions>
        /Users/oleary/BOL/machine-specific/CosmoTransitions2/
      </PathToCosmotransitions>
      <PathResolution>
        <!-- This is the number of nodes along the path between the false
             vacuum and the true vacuum that CosmoTransitions uses. If not
             given, 100 is used as the default. -->
        100
      </PathResolution>
      <MaxInnerLoops>
        <!-- This is the number of iterations of the inner loop that
             CosmoTransitions is allowed. The inner loop adjusts the path along
             the normal force directions. If not given, 10 is used as the
             default. -->
        10
      </MaxInnerLoops>
      <MaxOuterLoops>
        <!-- This is the number of iterations of the outer loop that
             CosmoTransitions is allowed. The outer loop adjusts the
             1-dimensional bounce action along the path then runs the inner
             loop. If not given, 10 is used as the default. -->
        10
      </MaxOuterLoops>
      <!-- End of set of elements only read if <ClassType> is
           "CosmoTransitionsRunner". -->
      <!-- The following elements are read only if <ClassType> is
           "BounceAlongPathWithThreshold", and are ignored if <ClassType> is
           "CosmoTransitionsRunner". -->
      <BouncePotentialFit>
        <!-- Currently the only valid option for <ClassType> is
             "BubbleShootingOnSpline", which implements the Coleman
             undershoot-overshoot method on a tunneling path from the true
             vacuum to the false vacuum, parameterizing the potential along the
             tunneling path by a fit to a set of potential energy densities at
             a set of values for the path parameterization variable. The number
             of segments between sampling points for this fit is given by
             <ConstructorArguments><NumberOfSegmentsForPotentialFit>.
             
             Currently, the way the potential is interpolated is fixed to being
             approximated as quadratic polynomials between nodes, with
             continuous slope between the spline segments. The first and last
             spline segments (i.e. each segment with a vacuum at one end) are
             taken as being in the form p^2 + const, where p is the distance
             from the vacuum end of the segment in the path parameterization
             variable, so the vacua are proper minima. Unfortunately it is
             crucial that the approximation in the neighborhoods of a vacuum
             has the properties that the slope vanishes exactly at the vacuum,
             decreasing monotonically as the distance from the vacuum
             decreases, and that very small distances from the vacuum are
             resolved precisely. If not, the undershoot/overshoot method
             implemented in VevaciousPlusPlus will break down, as the
             "particle rolling from one hill to another" might get stuck close
             to the true vacuum if the slope resolves to zero instead of
             10^-16, for example. A polynomial of degree
             NumberOfNodesForPotentialFit really failed in our test cases where
             the bubble would have a thin wall, as did quadratic splines
             without the extra care to have special cases for the first and
             last segments. -->
        <ClassType>
          BubbleShootingOnSpline
        </ClassType>
        <ConstructorArguments>
          <NumberOfSegmentsForPotentialFit>
            100
          </NumberOfSegmentsForPotentialFit>
          <NumberShootAttemptsAllowed>
            <!-- This is the number of shoot attempts allowed to try to find
                 the perfect shot before moving on with the best shot so far to
                 calculate the bounce action. -->
            32
          </NumberShootAttemptsAllowed>
          <RadialResolution>
            <!-- The initial step size in 1/GeV for numerically integrating the
                 bubble's equations of motion is given by the number given here
                 divided by the largest energy scale from the potential (from
                 among the Euclidean lengths of the vacua and the tunneling
                 scale given by the PotentialFunction object). -->
            0.05
          </RadialResolution>
        </ConstructorArguments>
      </BouncePotentialFit>
      <TunnelPathFinders>
        <!-- This should be a list, *in order*, of the various objects which
             will be used to try to find the dominant bounce action bubble
             configuration. This allows faster approximations to set up rough
             paths which are then refined by better approximations.
             
             Each path finder object should be enclosed in a "PathFinder" XML
             element, and the element should have just 2 child elements:
             "ClassType" and "ConstructorArguments".
             
             The valid path finder "ClassType" options are:
             "MinuitOnPotentialOnParallelPlanes", which just tries to minimize
             the energy barrier between the vacua, on planes without regard to
             how the path is between the planes;
             "MinuitOnPotentialPerpendicularToPath", which tries to minimize
             the barrier so that the force at points along the path is aligned
             locally with the path around each point;
             and "MinuitOnPathPerpendicularForces", which actually tries to do
             the same as "MinuitOnPotentialPerpendicularToPath" but with an
             extra term which, when differentiated, would give the effective
             force accounting for the rate of change of the field configuration
             with respect to the radial space-time variable (this is similar to
             the method used by CosmoTransitions right from the start, though
             should be a lot faster since it starts from what should be a good
             guess for the final path, and uses the power of Minuit2). -->
        <PathFinder>
          <ClassType>
            MinuitOnPotentialOnParallelPlanes
          </ClassType>
          <ConstructorArguments>
            <NumberOfPathSegments>
              <!-- This is the number of segments to break the path between
                   vacua in field space into, with the ends of the segments
                   being the points moved around, and the resulting path being
                   straight interpolations between these nodes. -->
              50
            </NumberOfPathSegments>
            <MinuitStrategy>
              <!-- The number given here is given to Minuit2 to decide how
                   precise it tries to be, through more or less calls of the
                   function to be minimized. The default is 1, while 0
                   emphasizes making less function calls, and 2 emphasizes more
                   accuracy through more function calls. -->
              1
            </MinuitStrategy>
            <MinuitTolerance>
              <!-- The number given here is a fraction to multiply Minuit2's
                   default 0.001 to yield the tolerance fraction, which is the
                   fraction of the value of the function at a point which is
                   used to compare to the estimated ("vertical") distance to
                   the minimum. For example, if 0.5 is given, then as soon as
                   Minuit2 estimates that it is at a point with function value
                   within 0.0005 of what it estimates is the value at the
                   minimum, it considers its minimization complete. -->
              0.5
            </MinuitTolerance>
          </ConstructorArguments>
        </PathFinder>
          <ClassType>
            MinuitOnPotentialPerpendicularToPath
          </ClassType>
          <ConstructorArguments>
            <NumberOfPathSegments>
              <!-- This is the number of segments to break the path between
                   vacua in field space into, with the ends of the segments
                   being the points moved around, and the resulting path being
                   straight interpolations between these nodes. -->
              100
            </NumberOfPathSegments>
            <NumberOfAllowedWorsenings>
              <!-- This is the number of times the
                   MinuitOnPotentialPerpendicularToPath is allowed to produce a
                   path with a higher bounce action than the last try before it
                   decides that it can no longer try to find a path with a
                   lower bounce action. -->
              3
            </NumberOfAllowedWorsenings>
            <MinuitStrategy>
              <!-- The number given here is given to Minuit2 to decide how
                   precise it tries to be, through more or less calls of the
                   function to be minimized. The default is 1, while 0
                   emphasizes making less function calls, and 2 emphasizes more
                   accuracy through more function calls. -->
              1
            </MinuitStrategy>
            <MinuitTolerance>
              <!-- The number given here is a fraction to multiply Minuit2's
                   default 0.001 to yield the tolerance fraction, which is the
                   fraction of the value of the function at a point which is
                   used to compare to the estimated ("vertical") distance to
                   the minimum. For example, if 0.5 is given, then as soon as
                   Minuit2 estimates that it is at a point with function value
                   within 0.0005 of what it estimates is the value at the
                   minimum, it considers its minimization complete. -->
              0.5
            </MinuitTolerance>
          </ConstructorArguments>
        </PathFinder>
        <!-- MinuitOnPathPerpendicularForces does not actually exist yet! -->
      </TunnelPathFinders>
      <!-- End of set of elements only read if <ClassType> is
           "BounceAlongPathWithThreshold". -->
    </ConstructorArguments>
  </TunnelingClass>

</VevaciousPlusPlusObjectInitialization>

