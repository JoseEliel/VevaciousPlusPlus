<VevaciousPlusPlusObjectInitialization>

<!--
#  VevaciousPlusPlusObjectInitialization.xml
#
#  Created on: Apr 10, 2014
#      Author: Ben O'Leary (benjamin.oleary@gmail.com)
#      Copyright 2014 Ben O'Leary
#
#      This file is part of VevaciousPlusPlus, released under the
#      GNU General Public License. Please see the accompanying
#      README.VevaciousPlusPlus.txt file for a full list of files, brief
#      documentation on how to use these classes, and further details on the
#      license.
#
 -->

<!-- Quick start: if you just want to change the model (i.e. the potential in
     terms of a set of fields), change
     <PotentialClass><ConstructorArguments><ModelFile> to the name of the file
     with the model in it (such as ./ModelFiles/TwoHiggsDoublet.vin or
     ./ModelFiles/RestrictedToRealVevsRealMssm.vin). Almost everything else is
     for tweaking the way in which the (meta)stability is calculated, such as
     the resolution of the tunneling path, or whether thermal tunneling is
     skipped, and so on. -->
 
  <PotentialClass>
    <!-- Currently <ClassType> must be either "FixedScaleOneLoopPotential" or
         "RgeImprovedOneLoopPotential". Both are classes that construct the
         potential energy density from a tree-level polynomial with one-loop
         corrections in the form of a polynomial of finite parts of
         counterterms along with the usual corrections from mass-squared
         eigenvalues in form m^4 ( ln[m^2/Q^2] - constant ), and thus both need
         <ConstructorArguments> to give the model file in <ModelFile>.
         Optionally, whether or not tree-level saddle points and maxima can be
         used as valid starting points for gradient-based minimization can be
         set in <RollOnlyMinima> within <ConstructorArguments> (defaulting to
         false). -->
    <ClassType>
      FixedScaleOneLoopPotential
    </ClassType>
    <ConstructorArguments>
      <ModelFile>
        <!-- /home/bol/BOL/Cplusplus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin -->
        <!-- /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/RestrictedToRealVevsRealMssm.vin -->
        /Users/oleary/BOL/Cplusplus/VevaciousPlusPlus/VevaciousPlusPlus/ModelFiles/LimitedMssm.vin
      </ModelFile>
      <RollOnlyMinima>
        <!-- Either "true"/"yes" or "false"/"no" (case-insensitive): if true
             then the starting points for MINUIT are only the subset of
             solutions from the homotopy continuation solutions which also are
             minima of the tree-level potential (so discarding tree-level
             maxima and saddle points). This should only be used if you are
             sure that the tree-level minima suffice to find every one-loop
             minimum with MINUIT, and it will only speed up this part of the
             run, while under usual circumstances it is the tunneling
             calculation which is the bottleneck. -->
        true
      </RollOnlyMinima>
      <ScaleRangeMinimumFactor>
      <!-- Another option: the maximum scale is at least the minimum scale in
           the SLHA file multiplied by the number given here. For example, if
           this number were 10.0, and the SLHA file had blocks at Q= 246.0 up
           to Q= 1000.0, the maximum scale would be pushed up to 2460.0; in
           contrast, if the number here were 2.0, the maximum scale would
           remain 1000.0 as opposed to 2.0 * 246.0 = 492.0 (for purposes of
           restricting MINUIT from rolling too far away from the region of
           validity, for example).
        10.0
      </ScaleRangeMinimumFactor>
    </ConstructorArguments>
  </PotentialClass>
  
  <MinimizerClass>
    <!-- Currently <ClassType> must be "GradientFromStartingPoints", and
         <ConstructorArguments> must give the <StartingPointFinderClass> and
         <GradientMinimizerClass> components. -->
    <ClassType>
      GradientFromStartingPoints
    </ClassType>
    <ConstructorArguments>
      <StartingPointFinderClass>
        <!-- Currently <ClassType> must be "Hom4ps2Runner", and
             <ConstructorArguments> must give the path to the directory with
             the hom4ps2 executable by <PathToHom4ps2> and the argument for the
              executable by <Hom4ps2Argument>. -->
        <ClassType>
          Hom4ps2Runner
        </ClassType>
        <ConstructorArguments>
          <PathToHom4ps2>
            <!-- /home/bol/BOL/machine-specific/HOM4PS2/ -->
            /Users/oleary/BOL/machine-specific/HOM4PS2/
          </PathToHom4ps2>
          <Hom4ps2Argument>
            <!-- The argument for HOM4PS2, as prompted by HOM4PS2:
                 "Please enter the option of homotopy method
                    1. The polyhedral homotopy
                    2. The classical linear homotopy"
                 1 can be faster for systems of many variables,
                 but 2 seems more reliable. -->
            2
          </Hom4ps2Argument>
        </ConstructorArguments>
      </StartingPointFinderClass>
      <GradientMinimizerClass>
        <!-- Currently <ClassType> must be "MinuitPotentialMinimizer" and
             <ConstructorArguments> must have <MinimaSeparationThreshold>. -->
        <ClassType>
          MinuitPotentialMinimizer
        </ClassType>
        <ConstructorArguments>
          <MinimaSeparationThreshold>
            <!-- The number here is the threshold fraction for considering
                 minima to be numerically distinct. For example, if this number
                 were 0.1, any minima separated by less than 10% of the shorter
                 of the 2 Euclidean lengths in field space would be considered
                 to be the same minimum that was almost reached twice without
                 getting the exact same minimum. -->
            0.1
          </MinimaSeparationThreshold>
        </ConstructorArguments>
      </GradientMinimizerClass>
    </ConstructorArguments>
  </MinimizerClass>
  
  <TunnelingClass>
    <!-- Currently <ClassType> must be either "BounceAlongPathWithThreshold" or
         "CosmoTransitionsRunner", both needing <ConstructorArguments> to have
         child elements <TunnelingStrategy> and <SurvivalProbabilityThreshold>.
         If <ClassType> is "CosmoTransitionsRunner", then
         <ConstructorArguments> must also give the path to the CosmoTransitions
         directory (where pathDeformation.py is) by <PathToCosmotransitions>,
         while "BounceAlongPathWithThreshold" needs <BouncePotentialFit> and
         <PathFinder>. -->
    <ClassType>
      MinuitBounceActionMinimizer
    </ClassType>
    <ConstructorArguments>
      <TunnelingStrategy>
        <!-- Valid options: "NoTunneling", "JustQuantum", "JustThermal",
                            "ThermalThenQuantum", or "QuantumThenThermal"
             (no quote marks in actual element). -->
        JustQuantum
      </TunnelingStrategy>
      <SurvivalProbabilityThreshold>
        0.01
      </SurvivalProbabilityThreshold>
      <PathToCosmotransitions>
        /Users/oleary/BOL/machine-specific/CosmoTransitions2/
      </PathToCosmotransitions>
      <BouncePotentialFit>
        <!-- This is how the potential energy density is parameterized along
             the tunneling path: it is a fit to a set of potential energy
             densities at a set of values for the path parameterization
             variable. The number of nodes for this fit is given by
             <NumberOfNodesForPotentialFit> (excluding the false vacuum and
             true vacuum, so if "3" were given, the potential would be fitted
             to 5 points: the false vacuum, the true vacuum, and 3 intermediate
             points).
             
             Currently, the way the potential is interpolated is fixed to being
             approximated as quadratic polynomials between nodes, with
             continuous slope between the spline segments. The first and last
             spline segments (i.e. each segment with a vacuum at one end) are
             taken as being in the form p^2 + const, where p is the distance
             from the vacuum end of the segment in the path parameterization
             variable, so the vacua are proper minima. Unfortunately it is
             crucial that the approximation in the neighborhoods of a vacuum
             has the properties that the slope vanishes exactly at the vacuum,
             decreasing monotonically as the distance from the vacuum
             decreases, and that very small distances from the vacuum are
             resolved precisely. If not, the undershoot/overshoot method
             implemented in VevaciousPlusPlus will break down, as the
             "particle rolling from one hill to another" might get stuck close
             to the true vacuum if the slope resolves to zero instead of
             10^-16, for example. A polynomial of degree
             NumberOfNodesForPotentialFit really failed in our test cases where
             the bubble would have a thin wall, as did quadratic splines
             without the extra care to have special cases for the first and
             last segments. -->
        <NumberOfNodesForPotentialFit>
          8
        </NumberOfNodesForPotentialFit>
      </BouncePotentialFit>
      <PathFinder>
        <ClassType>
        <!-- The valid options for this version of VevaciousPlusPlus are:
             "MinuitPathBounceMinimizer" (minimizing the bounce action along
             the tunneling path directly),
             "MinuitPathPotentialMinimizer" (minimizing the sum of values of
             the potential over a set of points along the tunneling path), or
             "MinuitNodePotentialMinimizer" (minimizing the potential over a
             set of points along the tunneling path on a node-by-node basis.
             Both "MinuitPathPotentialMinimizer" and
             "MinuitNodePotentialMinimizer" are close to the algorithm followed
             by CosmoTransitions. The difference between
             "MinuitPathPotentialMinimizer" and "MinuitNodePotentialMinimizer"
             is that the former can take a path parameterized in such a way
             that varying any parameter affects the whole path, while the
             latter requires that varying any parameter only varies the path in
             a very localized region, so that the sampled potential values are
             independent. The advantage of the latter is that it then reduces
             the minimization in an (n*f)-dimensional space, where there are n
             nodes with f free parameters per node, to n independent
             minimizations in an f-dimensional space. If using
             "MinuitNodePotentialMinimizer", <ConstructorArguments> here must
             have "PathFromNodesOnParallelPlanes" or
             "PathFromNodesOnBisectingPlanes" in
             <PathParameterization><ClassType>. -->
          MinuitNodePotentialMinimizer
        </ClassType>
        <ConstructorArguments>
          <NumberOfPotentialSamplePoints>
            <!-- If using "MinuitPathBounceMinimizer", this gives the number of
                 nodes used to fit the potential along the tunneling path for
                 the bounce action calculation. If using
                 "MinuitPathPotentialMinimizer", this gives the number of nodes
                 at which the potential will be evaluated for the sum, though
                 if <PathParameterization> has a larger number in
                 <ConstructorArguments><NumberOfVaryingNodes>, that will be
                 used instead. If using "MinuitNodePotentialMinimizer", this
                 number is ignored, as the number of nodes will be taken from
                 <ConstructorArguments><NumberOfVaryingNodes> in
                 <PathParameterization>. -->
          </NumberOfPotentialSamplePoints>
          <PathParameterization>
            <ClassType>
              <!-- The valid options for this version of VevaciousPlusPlus are:
                   "PathFromNodesOnParallelPlanes",
                   "PathFromNodesOnBisectingPlanes", or
                   "PathFromPolynomialCoefficients". The parameterization of
                   the first two is such that the field with greatest
                   difference between the false vacuum and true vacuum is taken
                   as the reference field, and the parameterization is (n*f)
                   values, where there are n varying nodes between the vacua
                   and f fields other than the reference field, so each node is
                   parameterized as a vector in the hyperplane where the
                   reference field has zero value. If using
                   "PathFromNodesOnParallelPlanes", that plane is then rotated
                   to be perpendicular to a vector going from false vacuum to
                   true vacuum, and then the node gets a multiple of that
                   vector, so the nodes end up on a series of parallel planes
                   between the vacua. The procedure if using
                   "PathFromNodesOnBisectingPlanes" is similar, except the
                   planes are those that bisect the vector between nodes: first
                   a node on a plane bisecting the vector between the vacua is
                   calculated, then a node between that node and the false
                   vacuum is calculated such that it lies on a plane
                   perpendicular to the vector from the false vacuum to the
                   node just calculated, and another node between the node just
                   calculated and the true vacuum in a similar manner is
                   calculated. If using "PathFromPolynomialCoefficients", then
                   the parameterization is a set of coefficients for
                   polynomials describing the dependence of the fields on the
                   auxiliary value p giving the distance along the path from
                   the false vacuum to the true vacuum, such that the reference
                   field is always linear in p, while the linear term
                   coefficients for the other fields are implicit such that the
                   true vacuum is reached at p = 1, so the coefficients
                   actually varied are those of the quadratic terms for each
                   field but the reference field, followed by a set of
                   coefficients for the cubic terms, and so on. -->
              PathFromNodesOnParallelPlanes
            </ClassType>
            <ConstructorArguments>
              <NumberOfCoefficientsPerVaryingField>
                <!-- This is only used by "PathFromPolynomialCoefficients", and
                     is ignored by "PathFromNodesOnParallelPlanes" and
                     "PathFromNodesOnBisectingPlanes". -->
                3
              </NumberOfCoefficientsPerVaryingField>
              <NumberOfVaryingNodes>
                <!-- This is only used by "PathFromNodesOnParallelPlanes" and
                     "PathFromNodesOnBisectingPlanes", and is ignored by
                     "PathFromPolynomialCoefficients". This is taken as a lower
                     bound by "PathFromNodesOnBisectingPlanes", as it requires
                     a number that is one less than an integer power of two
                     (so: 1, 3, 7, 15, 31, ...) and the lowest (2^n)-1 >= the
                     number given here will be taken. -->
                7
              </NumberOfVaryingNodes>
              <InterpolationStyle>
                <!-- This is only used by "PathFromNodesOnParallelPlanes" and
                     "PathFromNodesOnBisectingPlanes", and is ignored by
                     "PathFromPolynomialCoefficients".
                     The valid options for this version of VevaciousPlusPlus
                     are:
                     "PolynomialPath" (a single polynomial fit of degree (n+1),
                     with n = the number given by NumberOfVaryingNodes),
                     "LinearSplinePath" (approximated as a straight line
                     between the nodes), or
                     "QuadraticSplinePath" (approximated as quadratic
                     polynomials between nodes, with continuous slope between
                     the spline segments; the first segment is taken as linear
                     and each subsequent segment is constructed to have slope
                     continuous with its previous segment). -->
                LinearSplinePath
              </InterpolationStyle>
            </ConstructorArguments>
          </PathParameterization>
        </ConstructorArguments>
      </PathFinder>
    </ConstructorArguments>
  </TunnelingClass>

</VevaciousPlusPlusObjectInitialization>

